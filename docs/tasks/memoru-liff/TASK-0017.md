# TASK-0017: カード詳細・編集画面

**タスクID**: TASK-0017
**タスクタイプ**: TDD
**推定工数**: 6時間
**フェーズ**: Phase 3 - フロントエンド実装
**信頼性レベル**: 🟡 *user-stories.md 3.3より*

## 関連文書
- **概要**: [overview.md](overview.md)
- **要件定義**: [requirements.md](../../spec/memoru-liff/requirements.md) - REQ-013
- **設計文書**: [architecture.md](../../design/memoru-liff/architecture.md)

## タスク概要
カードの詳細表示と編集機能を提供する画面を実装する。表面・裏面の表示、編集モードへの切り替え、保存・削除処理を行う。

## 依存タスク
- **前提タスク**: TASK-0016（カード一覧画面）
- **後続タスク**: なし

## 完了条件
- [ ] カード詳細表示機能実装
- [ ] 編集モード切り替え機能実装
- [ ] 保存処理実装
- [ ] 削除処理実装
- [ ] 単体テスト80%以上のカバレッジ達成

---

## 実装詳細

### 1. カード詳細画面 🟡
**信頼性**: 🟡 *user-stories.md 3.3より*

カードの詳細表示と編集機能を提供する画面を実装する。

```typescript
// frontend/src/pages/CardDetailPage.tsx
import { useState, useEffect, useCallback } from 'react';
import { useParams, useNavigate } from 'react-router-dom';
import { CardForm } from '../components/CardForm';
import { Loading } from '../components/common/Loading';
import { Error } from '../components/common/Error';
import { cardsApi } from '../services/api';
import { Card } from '../types/card';
import { formatDueDate, getDueStatus } from '../utils/date';

export const CardDetailPage = () => {
  const { id } = useParams<{ id: string }>();
  const navigate = useNavigate();
  const [card, setCard] = useState<Card | null>(null);
  const [isLoading, setIsLoading] = useState(true);
  const [isEditing, setIsEditing] = useState(false);
  const [isSaving, setIsSaving] = useState(false);
  const [isDeleting, setIsDeleting] = useState(false);
  const [showDeleteConfirm, setShowDeleteConfirm] = useState(false);
  const [error, setError] = useState<string | null>(null);
  const [successMessage, setSuccessMessage] = useState<string | null>(null);

  const fetchCard = useCallback(async () => {
    if (!id) return;

    setIsLoading(true);
    setError(null);

    try {
      const data = await cardsApi.getCard(id);
      setCard(data);
    } catch (err) {
      setError('カードの取得に失敗しました');
    } finally {
      setIsLoading(false);
    }
  }, [id]);

  useEffect(() => {
    fetchCard();
  }, [fetchCard]);

  useEffect(() => {
    if (successMessage) {
      const timer = setTimeout(() => setSuccessMessage(null), 3000);
      return () => clearTimeout(timer);
    }
  }, [successMessage]);

  const handleSave = async (front: string, back: string) => {
    if (!id) return;

    setIsSaving(true);
    setError(null);

    try {
      const updatedCard = await cardsApi.updateCard(id, { front, back });
      setCard(updatedCard);
      setIsEditing(false);
      setSuccessMessage('カードを保存しました');
    } catch (err) {
      setError('カードの保存に失敗しました');
    } finally {
      setIsSaving(false);
    }
  };

  const handleDelete = async () => {
    if (!id) return;

    setIsDeleting(true);
    setError(null);

    try {
      await cardsApi.deleteCard(id);
      navigate('/cards', { state: { message: 'カードを削除しました' } });
    } catch (err) {
      setError('カードの削除に失敗しました');
      setShowDeleteConfirm(false);
    } finally {
      setIsDeleting(false);
    }
  };

  if (isLoading) {
    return <Loading message="カードを読み込み中..." />;
  }

  if (error && !card) {
    return <Error message={error} onRetry={fetchCard} />;
  }

  if (!card) {
    return <Error message="カードが見つかりません" />;
  }

  const dueStatus = getDueStatus(card.due);

  return (
    <div className="pb-20">
      <header className="bg-white shadow-sm p-4 mb-4">
        <div className="flex items-center justify-between">
          <button
            onClick={() => navigate(-1)}
            className="flex items-center text-gray-600 hover:text-gray-800 min-w-[44px] min-h-[44px]"
          >
            <svg className="w-6 h-6" fill="none" viewBox="0 0 24 24" stroke="currentColor">
              <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M15 19l-7-7 7-7" />
            </svg>
            <span className="ml-1">戻る</span>
          </button>
          {!isEditing && (
            <button
              onClick={() => setIsEditing(true)}
              className="text-blue-600 hover:text-blue-800 min-w-[44px] min-h-[44px] flex items-center"
            >
              <svg className="w-5 h-5 mr-1" fill="none" viewBox="0 0 24 24" stroke="currentColor">
                <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M11 5H6a2 2 0 00-2 2v11a2 2 0 002 2h11a2 2 0 002-2v-5m-1.414-9.414a2 2 0 112.828 2.828L11.828 15H9v-2.828l8.586-8.586z" />
              </svg>
              編集
            </button>
          )}
        </div>
      </header>

      {/* 成功メッセージ */}
      {successMessage && (
        <div className="mx-4 mb-4 p-3 bg-green-100 border border-green-300 text-green-700 rounded-lg">
          {successMessage}
        </div>
      )}

      {/* エラーメッセージ */}
      {error && (
        <div className="mx-4 mb-4 p-3 bg-red-100 border border-red-300 text-red-700 rounded-lg">
          {error}
        </div>
      )}

      <div className="px-4">
        {isEditing ? (
          /* 編集モード */
          <CardForm
            initialFront={card.front}
            initialBack={card.back}
            onSave={handleSave}
            onCancel={() => setIsEditing(false)}
            isSaving={isSaving}
          />
        ) : (
          /* 表示モード */
          <>
            <div className="bg-white rounded-lg shadow p-6 mb-4">
              <div className="mb-6">
                <span className="text-xs font-medium text-gray-500 uppercase">表面（質問）</span>
                <p className="text-lg text-gray-800 mt-2 whitespace-pre-wrap">{card.front}</p>
              </div>

              <div className="border-t pt-6">
                <span className="text-xs font-medium text-gray-500 uppercase">裏面（解答）</span>
                <p className="text-lg text-gray-800 mt-2 whitespace-pre-wrap">{card.back}</p>
              </div>
            </div>

            {/* メタ情報 */}
            <div className="bg-white rounded-lg shadow p-4 mb-6">
              <div className="flex justify-between items-center">
                <span className="text-sm text-gray-600">次回復習日</span>
                <span className={`text-sm font-medium ${
                  dueStatus.status === 'overdue' ? 'text-red-600' :
                  dueStatus.status === 'today' ? 'text-orange-600' :
                  'text-gray-800'
                }`}>
                  {formatDueDate(card.due)}
                </span>
              </div>
              <div className="flex justify-between items-center mt-2">
                <span className="text-sm text-gray-600">復習間隔</span>
                <span className="text-sm text-gray-800">{card.interval}日</span>
              </div>
            </div>

            {/* 削除ボタン */}
            <button
              onClick={() => setShowDeleteConfirm(true)}
              className="w-full py-3 text-red-600 border border-red-600 rounded-lg hover:bg-red-50 min-h-[44px]"
            >
              カードを削除
            </button>
          </>
        )}
      </div>

      {/* 削除確認ダイアログ */}
      {showDeleteConfirm && (
        <div className="fixed inset-0 bg-black bg-opacity-50 flex items-center justify-center z-50 p-4">
          <div className="bg-white rounded-lg p-6 max-w-sm w-full">
            <h3 className="text-lg font-semibold text-gray-800 mb-2">
              カードを削除しますか？
            </h3>
            <p className="text-gray-600 mb-6">
              この操作は取り消せません。
            </p>
            <div className="flex gap-3">
              <button
                onClick={() => setShowDeleteConfirm(false)}
                disabled={isDeleting}
                className="flex-1 py-3 bg-gray-200 text-gray-700 rounded-lg hover:bg-gray-300 min-h-[44px]"
              >
                キャンセル
              </button>
              <button
                onClick={handleDelete}
                disabled={isDeleting}
                className="flex-1 py-3 bg-red-600 text-white rounded-lg hover:bg-red-700 min-h-[44px]"
              >
                {isDeleting ? '削除中...' : '削除'}
              </button>
            </div>
          </div>
        </div>
      )}
    </div>
  );
};
```

**実装ファイル**: `frontend/src/pages/CardDetailPage.tsx`

### 2. カード編集フォームコンポーネント 🟡
**信頼性**: 🟡 *user-stories.md 3.3より*

カードの編集フォームを実装する。

```typescript
// frontend/src/components/CardForm.tsx
import { useState } from 'react';

interface CardFormProps {
  initialFront: string;
  initialBack: string;
  onSave: (front: string, back: string) => Promise<void>;
  onCancel: () => void;
  isSaving: boolean;
}

export const CardForm = ({
  initialFront,
  initialBack,
  onSave,
  onCancel,
  isSaving,
}: CardFormProps) => {
  const [front, setFront] = useState(initialFront);
  const [back, setBack] = useState(initialBack);

  const isValid = front.trim().length > 0 && back.trim().length > 0;
  const hasChanges = front !== initialFront || back !== initialBack;
  const canSave = isValid && hasChanges && !isSaving;

  const handleSubmit = async (e: React.FormEvent) => {
    e.preventDefault();
    if (!canSave) return;
    await onSave(front.trim(), back.trim());
  };

  return (
    <form onSubmit={handleSubmit} className="bg-white rounded-lg shadow p-6">
      <div className="mb-6">
        <label className="block text-sm font-medium text-gray-700 mb-2">
          表面（質問）
        </label>
        <textarea
          value={front}
          onChange={(e) => setFront(e.target.value)}
          placeholder="質問を入力..."
          className="w-full h-32 p-3 border border-gray-300 rounded-lg resize-none focus:ring-2 focus:ring-blue-500 focus:border-blue-500"
          disabled={isSaving}
        />
      </div>

      <div className="mb-6">
        <label className="block text-sm font-medium text-gray-700 mb-2">
          裏面（解答）
        </label>
        <textarea
          value={back}
          onChange={(e) => setBack(e.target.value)}
          placeholder="解答を入力..."
          className="w-full h-32 p-3 border border-gray-300 rounded-lg resize-none focus:ring-2 focus:ring-blue-500 focus:border-blue-500"
          disabled={isSaving}
        />
      </div>

      <div className="flex gap-3">
        <button
          type="button"
          onClick={onCancel}
          disabled={isSaving}
          className="flex-1 py-3 bg-gray-200 text-gray-700 rounded-lg hover:bg-gray-300 min-h-[44px]"
        >
          キャンセル
        </button>
        <button
          type="submit"
          disabled={!canSave}
          className={`flex-1 py-3 rounded-lg min-h-[44px] ${
            canSave
              ? 'bg-blue-600 text-white hover:bg-blue-700'
              : 'bg-gray-300 text-gray-500 cursor-not-allowed'
          }`}
        >
          {isSaving ? '保存中...' : '保存'}
        </button>
      </div>
    </form>
  );
};
```

**実装ファイル**: `frontend/src/components/CardForm.tsx`

### 3. API連携（カード詳細・更新・削除） 🔵
**信頼性**: 🔵 *architecture.mdより*

カードの詳細取得、更新、削除のAPI連携を実装する。

```typescript
// frontend/src/services/api.ts (部分)
export const cardsApi = {
  // ... 他のメソッド

  getCard: async (id: string): Promise<Card> => {
    const response = await apiClient.get<Card>(`/cards/${id}`);
    return response.data;
  },

  updateCard: async (id: string, updates: { front: string; back: string }): Promise<Card> => {
    const response = await apiClient.put<Card>(`/cards/${id}`, updates);
    return response.data;
  },

  deleteCard: async (id: string): Promise<void> => {
    await apiClient.delete(`/cards/${id}`);
  },
};
```

**実装ファイル**: `frontend/src/services/api.ts`

---

## 単体テスト要件

### テストケース1: カード詳細の表示 🟡
**信頼性**: 🟡 *user-stories.md 3.3より*
**Given**: カードIDが指定されている
**When**: カード詳細画面にアクセス
**Then**: カードの表面・裏面・メタ情報が表示される

### テストケース2: 編集モードへの切り替え 🟡
**信頼性**: 🟡 *user-stories.md 3.3より*
**Given**: カード詳細が表示されている
**When**: 編集ボタンをクリック
**Then**: 編集フォームが表示される

### テストケース3: 編集のキャンセル 🟡
**信頼性**: 🟡 *要件から妥当な推測*
**Given**: 編集モードが有効
**When**: キャンセルボタンをクリック
**Then**: 編集内容が破棄され、表示モードに戻る

### テストケース4: カードの保存 🔵
**信頼性**: 🔵 *REQ-013より*
**Given**: 編集モードで内容を変更
**When**: 保存ボタンをクリック
**Then**: カードが更新され、成功トーストが表示される

### テストケース5: 空の入力での保存防止 🟡
**信頼性**: 🟡 *要件から妥当な推測*
**Given**: 表面または裏面が空
**When**: 保存ボタンの状態を確認
**Then**: 保存ボタンが無効化されている

### テストケース6: 削除確認ダイアログの表示 🟡
**信頼性**: 🟡 *要件から妥当な推測*
**Given**: カード詳細が表示されている
**When**: 削除ボタンをクリック
**Then**: 確認ダイアログが表示される

### テストケース7: 削除のキャンセル 🟡
**信頼性**: 🟡 *要件から妥当な推測*
**Given**: 削除確認ダイアログが表示されている
**When**: キャンセルボタンをクリック
**Then**: ダイアログが閉じ、カードは削除されない

### テストケース8: カードの削除 🔵
**信頼性**: 🔵 *REQ-013より*
**Given**: 削除確認ダイアログが表示されている
**When**: 削除ボタンをクリック
**Then**: カードが削除され、一覧画面に遷移する

### テストケース9: 存在しないカードへのアクセス 🟡
**信頼性**: 🟡 *要件から妥当な推測*
**Given**: 存在しないカードIDが指定されている
**When**: カード詳細画面にアクセス
**Then**: エラーメッセージが表示される

---

## UI/UX要件

### ローディング状態 🔵
**信頼性**: 🔵 *NFR-201より*
- カード取得中はローディングスピナーを表示
- 保存中・削除中はボタンに「...中」を表示

### エラー表示 🟡
**信頼性**: 🟡 *要件から妥当な推測*
- API取得エラー時はエラーメッセージを表示
- 保存・削除エラー時はインラインエラーを表示

### 削除確認ダイアログ 🟡
**信頼性**: 🟡 *要件から妥当な推測*
- 削除前に確認ダイアログを表示
- 「この操作は取り消せません」の警告文を表示
- キャンセルボタンを左に、削除ボタンを右に配置

### 保存成功トースト 🟡
**信頼性**: 🟡 *要件から妥当な推測*
- 保存成功時は「カードを保存しました」を表示
- 3秒後に自動で非表示

### モバイル対応 🔵
**信頼性**: 🔵 *NFR-201より*
- テキストエリアはスクロール可能
- ボタンは44px以上のタッチ領域
- ダイアログはモバイル画面に最適化

---

## 実装手順

### TDDタスクの場合
1. `/tsumiki:tdd-requirements TASK-0017` - 詳細要件定義
2. `/tsumiki:tdd-testcases` - テストケース作成
3. `/tsumiki:tdd-red` - テスト実装（失敗）
4. `/tsumiki:tdd-green` - 最小実装
5. `/tsumiki:tdd-refactor` - リファクタリング
6. `/tsumiki:tdd-verify-complete` - 品質確認

---

## 注意事項
- 編集中の内容は一時保存されないため、離脱時の警告を検討
- 削除は取り消せないため、確認ダイアログを必須とする
- URLにカードIDを含めることで、ブックマークや共有に対応
- 戻るボタンはブラウザ履歴を使用

---

## 信頼性レベルサマリー
- 🔵 **青信号**: 5項目
- 🟡 **黄信号**: 12項目
- 🔴 **赤信号**: 0項目

**品質評価**: 要改善（黄信号項目の詳細確認が必要）
