# code-review-remediation 受け入れ基準

**作成日**: 2026-02-15
**関連要件定義**: [requirements.md](requirements.md)
**関連ユーザストーリー**: [user-stories.md](user-stories.md)
**ヒアリング記録**: [interview-record.md](interview-record.md)

**【信頼性レベル凡例】**:

- 🔵 **青信号**: コードレビュー結果・既存設計文書・実装コードから確実に特定された基準
- 🟡 **黄信号**: コードレビュー結果から妥当な推測による基準
- 🔴 **赤信号**: コードレビュー結果にない推測による基準

---

## Phase 1: Critical 修正

### REQ-CR-001, 002: API ルート統一 🔵

**信頼性**: 🔵 *C-01: handler.py, template.yaml, api.ts の実装から確認*

#### Given（前提条件）

- Backend ハンドラー、SAM テンプレート、Frontend API クライアントが存在する
- 設計文書 `api-endpoints.md` の API パス定義がある

#### When（実行条件）

- Frontend から復習期限カード取得 API を呼び出す

#### Then（期待結果）

- Backend ハンドラーのルート定義、SAM テンプレートの Path、Frontend API クライアントのパスが全て一致する
- API Gateway が正しく Lambda にルーティングする
- 404/405 エラーが発生しない

#### テストケース

##### 正常系

- [ ] **TC-CR-001-01**: 復習期限カード取得が正常動作 🔵
  - **入力**: `GET /reviews/due` リクエスト（認証済みユーザー）
  - **期待結果**: 200 OK、復習期限のカード一覧が返却
  - **信頼性**: 🔵 *C-01: 設計文書のパス定義から*

- [ ] **TC-CR-001-02**: 全 API パスの一致確認 🔵
  - **入力**: 全エンドポイントの API パスを照合
  - **期待結果**: handler.py、template.yaml、api.ts の全パスが一致
  - **信頼性**: 🔵 *C-01: 静的検証*

##### 異常系

- [ ] **TC-CR-001-E01**: 存在しないパスへのリクエスト 🟡
  - **入力**: `GET /cards/due`（旧パス）
  - **期待結果**: 404 Not Found
  - **信頼性**: 🟡 *旧パスの動作確認*

---

### REQ-CR-003: API レスポンス契約統一 🔵

**信頼性**: 🔵 *C-02: Backend モデルと Frontend 型定義の実装から確認*

#### Given（前提条件）

- Backend の Pydantic レスポンスモデル（Card, User）が存在する
- Frontend の TypeScript 型定義（card.ts, user.ts）が存在する

#### When（実行条件）

- Backend がレスポンスモデルを JSON に変換して返却する

#### Then（期待結果）

- 全フィールド名が Backend と Frontend で一致する
- フィールドの型（string/number/boolean/array）が一致する
- Optional フィールドの扱いが一致する

#### テストケース

##### 正常系

- [ ] **TC-CR-003-01**: Card モデルのフィールド一致 🔵
  - **入力**: Backend から Card レスポンスを返却
  - **期待結果**: Frontend の `Card` 型の全フィールドに値が入る（`undefined` なし）
  - **信頼性**: 🔵 *C-02: 既存モデル比較*

- [ ] **TC-CR-003-02**: User モデルのフィールド一致 🔵
  - **入力**: Backend から User レスポンスを返却
  - **期待結果**: Frontend の `User` 型の全フィールドに値が入る
  - **信頼性**: 🔵 *C-02: 既存モデル比較*

- [ ] **TC-CR-003-03**: カード一覧レスポンスのページネーション 🔵
  - **入力**: `GET /cards?limit=20`
  - **期待結果**: レスポンスの構造（items, next_token 等）が Frontend の期待と一致
  - **信頼性**: 🔵 *api-endpoints.md の定義から*

##### 異常系

- [ ] **TC-CR-003-E01**: Optional フィールドが null の場合 🟡
  - **入力**: `line_user_id` が null の User レスポンス
  - **期待結果**: Frontend が null を正しくハンドリング
  - **信頼性**: 🟡 *Nullable フィールドの扱い*

---

### REQ-CR-005: OIDC コールバック実装 🔵

**信頼性**: 🔵 *C-03: CallbackPage.tsx と auth.ts の実装から確認*

#### Given（前提条件）

- ユーザーが Keycloak で認証を完了している
- コールバック URL に認可コードが含まれている

#### When（実行条件）

- CallbackPage コンポーネントがマウントされる

#### Then（期待結果）

- `authService.handleCallback()` が呼び出される
- アクセストークンとリフレッシュトークンが保存される
- ホーム画面にリダイレクトされる

#### テストケース

##### 正常系

- [ ] **TC-CR-005-01**: 正常な OIDC コールバック処理 🔵
  - **入力**: 有効な認可コードを含むコールバック URL
  - **期待結果**: トークン取得成功、ホーム画面にリダイレクト
  - **信頼性**: 🔵 *C-03: PKCE フロー仕様*

- [ ] **TC-CR-005-02**: handleCallback 呼び出し確認 🔵
  - **入力**: CallbackPage マウント
  - **期待結果**: `authService.handleCallback()` が 1 回呼び出される
  - **信頼性**: 🔵 *C-03: 既存コードの修正*

##### 異常系

- [ ] **TC-CR-005-E01**: コールバック URL にエラーパラメータ 🟡
  - **入力**: `?error=access_denied&error_description=...`
  - **期待結果**: エラーメッセージが表示される
  - **信頼性**: 🟡 *OIDC 仕様から推測*

- [ ] **TC-CR-005-E02**: 認可コードが無効 🔵
  - **入力**: 期限切れの認可コード
  - **期待結果**: エラー処理、ログイン画面にリダイレクト
  - **信頼性**: 🔵 *OIDC 仕様*

---

### REQ-CR-012: DuePush Lambda IAM 権限 🔵

**信頼性**: 🔵 *C-04: template.yaml の IAM ポリシーから確認*

#### Given（前提条件）

- DuePush Lambda が EventBridge からトリガーされる
- 通知対象ユーザーに LINE Push を送信済み

#### When（実行条件）

- Lambda が Users テーブルの `last_notified_date` を更新する

#### Then（期待結果）

- `dynamodb:UpdateItem` が成功する
- 次回実行時に同一ユーザーへの重複通知が防止される

#### テストケース

##### 正常系

- [ ] **TC-CR-012-01**: last_notified_date 更新成功 🔵
  - **入力**: 通知送信後の `last_notified_date` 更新
  - **期待結果**: Users テーブルの当該ユーザーの `last_notified_date` が更新される
  - **信頼性**: 🔵 *C-04: IAM ポリシー修正*

##### 異常系

- [ ] **TC-CR-012-E01**: IAM ポリシー検証 🔵
  - **入力**: SAM テンプレートの DuePush Lambda IAM ポリシーを確認
  - **期待結果**: Users テーブルへの `dynamodb:UpdateItem` 権限が含まれている
  - **信頼性**: 🔵 *C-04: テンプレート検証*

---

### REQ-CR-004, 101: 204 レスポンス処理 🔵

**信頼性**: 🔵 *C-05: api.ts の実装から確認*

#### Given（前提条件）

- Frontend が DELETE API を呼び出す

#### When（実行条件）

- Backend が 204 No Content を返却する

#### Then（期待結果）

- `response.json()` が呼び出されない
- `undefined` が返却される
- 呼び出し元が正常に成功処理を行う

#### テストケース

##### 正常系

- [ ] **TC-CR-004-01**: 204 レスポンスの正常処理 🔵
  - **入力**: DELETE リクエストに対する 204 No Content レスポンス
  - **期待結果**: JSON パースエラーが発生せず、`undefined` が返却
  - **信頼性**: 🔵 *C-05: api.ts の修正*

- [ ] **TC-CR-004-02**: 200 レスポンスは従来通り JSON パース 🔵
  - **入力**: GET リクエストに対する 200 OK + JSON ボディ
  - **期待結果**: `response.json()` が呼び出され、パース結果が返却
  - **信頼性**: 🔵 *既存動作の回帰確認*

---

### REQ-CR-009: LINE 署名タイミング攻撃対策 🔵

**信頼性**: 🔵 *C-06: line_service.py の実装から確認*

#### Given（前提条件）

- LINE Webhook リクエストが到着する

#### When（実行条件）

- `verify_signature()` が呼び出される

#### Then（期待結果）

- 空署名の場合も `hmac.compare_digest` を通す
- 不正な署名と正しい署名の検証時間に統計的有意差がない

#### テストケース

##### 正常系

- [ ] **TC-CR-009-01**: 正しい署名の検証 🔵
  - **入力**: 正しい HMAC-SHA256 署名
  - **期待結果**: `True` が返却
  - **信頼性**: 🔵 *既存テストの確認*

##### 異常系

- [ ] **TC-CR-009-E01**: 空署名の検証 🔵
  - **入力**: 空文字列の署名
  - **期待結果**: `False` が返却、`hmac.compare_digest` が使用される
  - **信頼性**: 🔵 *C-06: タイミング攻撃対策*

- [ ] **TC-CR-009-E02**: None 署名の検証 🔵
  - **入力**: `None` の署名
  - **期待結果**: `False` が返却、例外が発生しない
  - **信頼性**: 🔵 *C-06: Null ハンドリング*

- [ ] **TC-CR-009-E03**: 不正署名の検証 🔵
  - **入力**: 不正な Base64 署名
  - **期待結果**: `False` が返却
  - **信頼性**: 🔵 *既存テストの確認*

---

### REQ-CR-006: 環境変数バリデーション 🔵

**信頼性**: 🔵 *C-07: oidc.ts と main.tsx の実装から確認*

#### Given（前提条件）

- アプリケーションが起動する

#### When（実行条件）

- `main.tsx` の初期化処理が実行される

#### Then（期待結果）

- `validateOidcConfig()` が呼び出される
- 必須環境変数が未設定の場合、明確なエラーメッセージが出力される
- 全環境変数が設定済みの場合、React アプリが正常にマウントされる

#### テストケース

##### 正常系

- [ ] **TC-CR-006-01**: 全環境変数が設定済み 🔵
  - **入力**: 全必須環境変数が設定された状態
  - **期待結果**: アプリが正常に起動
  - **信頼性**: 🔵 *C-07: 既存バリデーション関数*

##### 異常系

- [ ] **TC-CR-006-E01**: OIDC Authority が未設定 🔵
  - **入力**: `VITE_OIDC_AUTHORITY` が空
  - **期待結果**: 明確なエラーメッセージが表示
  - **信頼性**: 🔵 *C-07: バリデーション動作*

- [ ] **TC-CR-006-E02**: 複数の環境変数が未設定 🟡
  - **入力**: OIDC Authority と Client ID の両方が空
  - **期待結果**: 全ての未設定変数名がエラーメッセージに含まれる
  - **信頼性**: 🟡 *バリデーション詳細の推測*

---

## Phase 2: High 修正

### REQ-CR-013: datetime 統一 🔵

**信頼性**: 🔵 *H-01: 複数ファイルの実装から確認*

#### Given（前提条件）

- Backend の datetime 処理が複数箇所に存在する

#### When（実行条件）

- SRS 計算、カード作成、レビュー記録で datetime が使用される

#### Then（期待結果）

- 全箇所で `datetime.now(timezone.utc)` が使用される
- `datetime.utcnow()` の使用箇所がゼロ
- naive datetime と aware datetime の比較による TypeError が発生しない

#### テストケース

##### 正常系

- [ ] **TC-CR-013-01**: due 計算の正常動作 🔵
  - **入力**: SM-2 アルゴリズムによる due 日時計算
  - **期待結果**: timezone-aware な datetime が返却
  - **信頼性**: 🔵 *H-01: srs.py の修正*

- [ ] **TC-CR-013-02**: datetime.utcnow() の不在確認 🔵
  - **入力**: 全ソースコードの grep 検索
  - **期待結果**: `datetime.utcnow()` の使用箇所がゼロ
  - **信頼性**: 🔵 *H-01: 静的検証*

##### 異常系

- [ ] **TC-CR-013-E01**: 日付境界での計算 🟡
  - **入力**: UTC 00:00:00 をまたぐ due 計算
  - **期待結果**: 正しい日付の due が計算される
  - **信頼性**: 🟡 *H-01: 境界値テスト*

---

### REQ-CR-010: CSP 強化 🔵

**信頼性**: 🔵 *H-02: liff-hosting/template.yaml の実装から確認*

#### Given（前提条件）

- CloudFront の ResponseHeadersPolicy に CSP が設定されている

#### When（実行条件）

- LIFF アプリにブラウザからアクセスする

#### Then（期待結果）

- `unsafe-eval` が CSP に含まれない
- LIFF アプリが正常に動作する

#### テストケース

##### 正常系

- [ ] **TC-CR-010-01**: CSP ヘッダーから unsafe-eval が除去 🔵
  - **入力**: CloudFront テンプレートの CSP 設定を確認
  - **期待結果**: `unsafe-eval` が含まれない
  - **信頼性**: 🔵 *H-02: テンプレート検証*

- [ ] **TC-CR-010-02**: LIFF アプリの動作確認 🟡
  - **入力**: CSP 制約下で LIFF アプリにアクセス
  - **期待結果**: JavaScript エラーなく動作
  - **信頼性**: 🟡 *LIFF SDK との互換性は要確認*

---

### REQ-CR-011, 105: Keycloak HTTPS 強制 🔵

**信頼性**: 🔵 *H-03: keycloak/template.yaml の実装から確認*

#### Given（前提条件）

- Keycloak が ECS/Fargate 上で稼働している

#### When（実行条件）

- 本番環境で Keycloak にアクセスする

#### Then（期待結果）

- HTTP 接続が拒否またはリダイレクトされる
- HTTPS のみ受け付ける

#### テストケース

##### 正常系

- [ ] **TC-CR-011-01**: 本番テンプレートで HTTP 無効化 🔵
  - **入力**: 本番環境用の Keycloak テンプレートパラメータを確認
  - **期待結果**: `KC_HTTP_ENABLED=false` または同等の設定
  - **信頼性**: 🔵 *H-03: テンプレート検証*

- [ ] **TC-CR-011-02**: 開発環境で HTTP 許可 🟡
  - **入力**: 開発環境用のパラメータを確認
  - **期待結果**: HTTP が許可されている
  - **信頼性**: 🟡 *開発用の設定は推測*

---

### REQ-CR-018: LINE 連携解除 API 🔵

**信頼性**: 🔵 *H-04: Frontend UI と Backend の実装差から確認*

#### Given（前提条件）

- ユーザーが LINE 連携済みの状態

#### When（実行条件）

- ユーザーが LINE 連携解除を実行する

#### Then（期待結果）

- Backend API がユーザーの `line_user_id` をクリアする
- LINE 通知が停止される
- Frontend に成功レスポンスが返却される

#### テストケース

##### 正常系

- [ ] **TC-CR-018-01**: LINE 連携解除 API の正常動作 🔵
  - **入力**: `POST /users/me/unlink-line` (認証済み)
  - **期待結果**: 200 OK、`line_user_id` が null に更新
  - **信頼性**: 🔵 *H-04: 新規エンドポイント*

##### 異常系

- [ ] **TC-CR-018-E01**: 未連携状態での解除試行 🟡
  - **入力**: `line_user_id` が null のユーザーが解除を試行
  - **期待結果**: 適切なエラーメッセージ（既に未連携）
  - **信頼性**: 🟡 *エラーケースは推測*

---

### REQ-CR-014: 通知 cron 修正 🔵

**信頼性**: 🔵 *H-05: template.yaml の実装から確認*

#### Given（前提条件）

- SAM テンプレートに EventBridge cron 式が定義されている

#### When（実行条件）

- EventBridge が Lambda をトリガーする

#### Then（期待結果）

- cron 式が意図した時刻を表現している
- コメントの記述と cron 式が一致する

#### テストケース

##### 正常系

- [ ] **TC-CR-014-01**: cron 式とコメントの一致 🔵
  - **入力**: template.yaml の cron 定義を確認
  - **期待結果**: コメントの時刻と cron 式が同一の時刻を表す
  - **信頼性**: 🔵 *H-05: 静的検証*

---

### REQ-CR-015: Race Condition 対策 🔵

**信頼性**: 🔵 *H-06: card_service.py の実装から確認*

#### Given（前提条件）

- ユーザーのカード数が上限（2,000 枚）に近い

#### When（実行条件）

- 同時に複数のカード作成リクエストが到着する

#### Then（期待結果）

- DynamoDB の ConditionExpression で原子的にチェック
- カード数が上限を超えない

#### テストケース

##### 正常系

- [ ] **TC-CR-015-01**: 単一リクエストでの制限チェック 🔵
  - **入力**: カード数 2,000 枚の状態でカード作成
  - **期待結果**: エラーレスポンス（制限超過）
  - **信頼性**: 🔵 *H-06: 既存テストの更新*

##### 境界値

- [ ] **TC-CR-015-B01**: 制限ちょうどでの並行作成 🔵
  - **入力**: カード数 1,999 枚で 2 つの同時作成リクエスト
  - **期待結果**: 1 つのみ成功、もう 1 つは拒否
  - **信頼性**: 🔵 *H-06: Race Condition テスト*

---

### REQ-CR-016: Bedrock リトライジッター 🔵

**信頼性**: 🔵 *H-07: bedrock.py の実装から確認*

#### Given（前提条件）

- Bedrock API がスロットリングエラーを返す

#### When（実行条件）

- Lambda がリトライを実行する

#### Then（期待結果）

- フルジッター付き Exponential Backoff が適用される
- リトライ間隔がランダムに分散される

#### テストケース

##### 正常系

- [ ] **TC-CR-016-01**: ジッター付きリトライ間隔 🔵
  - **入力**: 3 回連続のリトライ
  - **期待結果**: リトライ間隔がランダム値（0 〜 2^attempt の範囲）
  - **信頼性**: 🔵 *H-07: bedrock.py の修正*

- [ ] **TC-CR-016-02**: リトライ上限の確認 🟡
  - **入力**: 最大リトライ回数に達した場合
  - **期待結果**: 例外が raise される
  - **信頼性**: 🟡 *リトライ上限の動作確認*

---

### REQ-CR-007, 102, 103: Token リフレッシュ 🟡

**信頼性**: 🟡 *H-08: api.ts に機能なし、実装パターンは推測*

#### Given（前提条件）

- ユーザーがログイン済みでリフレッシュトークンが保存されている

#### When（実行条件）

- API レスポンスが 401 を返す

#### Then（期待結果）

- リフレッシュトークンで新しいアクセストークンを取得
- 元のリクエストがリトライされる
- リフレッシュも失敗した場合はログイン画面にリダイレクト

#### テストケース

##### 正常系

- [ ] **TC-CR-007-01**: トークンリフレッシュ成功 🟡
  - **入力**: 401 レスポンス + 有効なリフレッシュトークン
  - **期待結果**: 新しいアクセストークン取得、リクエストリトライ成功
  - **信頼性**: 🟡 *H-08: 実装パターンから推測*

##### 異常系

- [ ] **TC-CR-007-E01**: リフレッシュトークンも期限切れ 🟡
  - **入力**: 401 レスポンス + 期限切れリフレッシュトークン
  - **期待結果**: ログイン画面にリダイレクト
  - **信頼性**: 🟡 *H-08: フォールバック動作*

- [ ] **TC-CR-007-E02**: 並行リクエストでのリフレッシュ 🟡
  - **入力**: 複数 API リクエストが同時に 401 を受信
  - **期待結果**: リフレッシュが 1 回のみ実行される
  - **信頼性**: 🟡 *EDGE-CR-003: 並行リフレッシュ防止*

---

### REQ-CR-008, 104: ProtectedRoute 修正 🔵

**信頼性**: 🔵 *H-09: ProtectedRoute.tsx の実装から確認*

#### Given（前提条件）

- 未認証ユーザーが ProtectedRoute にアクセスする

#### When（実行条件）

- ProtectedRoute コンポーネントがレンダリングされる

#### Then（期待結果）

- `login()` が 1 回のみ呼び出される
- `login()` 失敗時に無限ループが発生しない

#### テストケース

##### 正常系

- [ ] **TC-CR-008-01**: 初回 login 呼び出し 🔵
  - **入力**: 未認証状態で ProtectedRoute にアクセス
  - **期待結果**: `login()` が 1 回呼び出される
  - **信頼性**: 🔵 *H-09: loginAttempted フラグ*

##### 異常系

- [ ] **TC-CR-008-E01**: login 失敗時のハンドリング 🔵
  - **入力**: `login()` が例外を throw
  - **期待結果**: エラー画面が表示、無限ループしない
  - **信頼性**: 🔵 *H-09: 無限ループ防止*

---

### REQ-CR-017: Context API メモ化 🔵

**信頼性**: 🔵 *H-10: CardsContext.tsx, AuthContext.tsx の実装から確認*

#### Given（前提条件）

- CardsContext と AuthContext の Provider が存在する

#### When（実行条件）

- 親コンポーネントが再レンダリングされる

#### Then（期待結果）

- Provider の値が `useMemo` でメモ化されている
- コールバック関数が `useCallback` でメモ化されている
- 値が変化していない場合、Consumer は再レンダリングされない

#### テストケース

##### 正常系

- [ ] **TC-CR-017-01**: useMemo 適用確認 🔵
  - **入力**: Context Provider のソースコードを確認
  - **期待結果**: Provider value が `useMemo` でラップされている
  - **信頼性**: 🔵 *H-10: 静的検証*

- [ ] **TC-CR-017-02**: useCallback 適用確認 🔵
  - **入力**: Context Provider のコールバック関数を確認
  - **期待結果**: コールバックが `useCallback` でラップされている
  - **信頼性**: 🔵 *H-10: 静的検証*

---

### REQ-CR-413, 414: インフラコスト最適化 🟡

**信頼性**: 🟡 *H-11, H-12: Claude Infra が検出、設定値は推定*

#### Given（前提条件）

- 開発環境の CloudFormation テンプレートが存在する

#### When（実行条件）

- テンプレートを適用する

#### Then（期待結果）

- 開発環境の NAT Gateway が削除されている（または削除可能な構成）
- CloudWatch Logs に保存期間が設定されている

#### テストケース

##### 正常系

- [ ] **TC-CR-414-01**: CloudWatch Logs 保存期間設定 🟡
  - **入力**: SAM テンプレートの LogGroup 定義を確認
  - **期待結果**: `RetentionInDays` が設定されている（本番 90 日、開発 14 日）
  - **信頼性**: 🟡 *H-12: 推奨値から*

- [ ] **TC-CR-414-02**: NAT Gateway 削除確認 🟡
  - **入力**: 開発環境の Keycloak テンプレートを確認
  - **期待結果**: NAT Gateway リソースが条件付きまたは削除
  - **信頼性**: 🟡 *H-11: コスト最適化*

---

## テストケースサマリー

### カテゴリ別件数

| カテゴリ | 正常系 | 異常系 | 境界値 | 合計 |
|---------|--------|--------|--------|------|
| Phase 1 (Critical) | 13 | 9 | 0 | 22 |
| Phase 2 (High) | 11 | 5 | 1 | 17 |
| **合計** | **24** | **14** | **1** | **39** |

### 信頼性レベル分布

- 🔵 青信号: 30件 (77%)
- 🟡 黄信号: 9件 (23%)
- 🔴 赤信号: 0件 (0%)

**品質評価**: ✅ 高品質（青信号が77%、赤信号なし）

### 優先度別テストケース

- **Must Have（Phase 1 Critical）**: 22件
- **Should Have（Phase 2 High）**: 17件

---

## テスト実施計画

### Phase 1: Critical 修正テスト（1 週間以内）

- REQ-CR-001 ~ REQ-CR-012: API 契約、認証、セキュリティ、IAM
- 優先度: Must Have
- テストケース: 22 件

### Phase 2: High 修正テスト（2 週間以内）

- REQ-CR-013 ~ REQ-CR-018: データ整合性、品質、インフラ
- 優先度: Should Have
- テストケース: 17 件

### 回帰テスト

- 既存テストスイート（backend `make test`, frontend `npm test`）の全件パスを確認
- 修正箇所に関連する既存テストの更新
