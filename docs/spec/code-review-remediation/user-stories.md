# code-review-remediation ユーザストーリー

**作成日**: 2026-02-15
**関連要件定義**: [requirements.md](requirements.md)
**ヒアリング記録**: [interview-record.md](interview-record.md)

**【信頼性レベル凡例】**:

- 🔵 **青信号**: コードレビュー結果・既存設計文書・実装コードから確実に特定されたストーリー
- 🟡 **黄信号**: コードレビュー結果から妥当な推測によるストーリー
- 🔴 **赤信号**: コードレビュー結果にない推測によるストーリー

---

## エピック1: API 契約の整合性確保

### ストーリー 1.1: API ルートの統一 🔵

**信頼性**: 🔵 *C-01: Codex + Claude Backend が独立検出*

**私は** Memoru LIFF ユーザー **として**
**復習期限のカードを正しく取得したい**
**そうすることで** 復習機能が本番環境で正常に動作する

**関連要件**: REQ-CR-001, REQ-CR-002

**詳細シナリオ**:

1. ユーザーがホーム画面を開く
2. Frontend が `/reviews/due` エンドポイントにリクエストを送信
3. API Gateway がリクエストを Lambda にルーティング
4. Lambda ハンドラーが復習期限カードを返却
5. Frontend が正しくカード一覧を表示

**前提条件**:

- Backend ハンドラー、SAM テンプレート、Frontend API クライアントのパスが全て統一されている

**制約事項**:

- 設計文書 `api-endpoints.md` の定義を正とする

**優先度**: Must Have

---

### ストーリー 1.2: API レスポンス型の統一 🔵

**信頼性**: 🔵 *C-02: Codex が型レベルの詳細比較で検出*

**私は** Memoru LIFF ユーザー **として**
**カード情報やユーザー情報を正しい形式で受け取りたい**
**そうすることで** 画面上で undefined エラーが発生しない

**関連要件**: REQ-CR-003

**詳細シナリオ**:

1. Frontend がカード一覧 API を呼び出す
2. Backend が Card レスポンスモデルで返却
3. Frontend の TypeScript 型定義と一致するフィールド名・構造で受信
4. 画面上にカード情報が正しく表示される

**前提条件**:

- Backend の Pydantic モデルと Frontend の TypeScript 型が同一のフィールド名・構造

**優先度**: Must Have

---

### ストーリー 1.3: 204 レスポンスの正常処理 🔵

**信頼性**: 🔵 *C-05: Codex が検出*

**私は** Memoru LIFF ユーザー **として**
**カードを削除した後に成功メッセージを見たい**
**そうすることで** 削除が正常に完了したことを確認できる

**関連要件**: REQ-CR-004, REQ-CR-101

**詳細シナリオ**:

1. ユーザーがカード詳細画面で削除ボタンを押す
2. Frontend が DELETE API を呼び出す
3. Backend が 204 No Content を返却
4. Frontend が JSON パースをスキップし、成功として処理
5. ユーザーにカード一覧画面に戻り、削除されたカードが表示されない

**優先度**: Must Have

---

## エピック2: 認証フローの完成

### ストーリー 2.1: OIDC コールバックの実装 🔵

**信頼性**: 🔵 *C-03: Codex + Claude Frontend が最重要と判定*

**私は** Memoru LIFF ユーザー **として**
**Keycloak ログイン後にアプリに正常に戻りたい**
**そうすることで** アプリケーションを使用開始できる

**関連要件**: REQ-CR-005

**詳細シナリオ**:

1. ユーザーが Keycloak ログイン画面で認証を完了
2. Keycloak がコールバック URL にリダイレクト
3. CallbackPage で `authService.handleCallback()` が呼び出される
4. PKCE コードからアクセストークン・リフレッシュトークンを取得
5. トークンが保存され、ホーム画面にリダイレクト

**前提条件**:

- Keycloak が稼働している
- OIDC Client 設定が完了している

**制約事項**:

- PKCE フローを使用

**優先度**: Must Have

---

### ストーリー 2.2: 環境変数バリデーション 🔵

**信頼性**: 🔵 *C-07: Claude Frontend が検出*

**私は** 開発者 **として**
**必須環境変数が未設定の場合にアプリ起動時にエラーを確認したい**
**そうすることで** 本番デプロイ前に設定ミスを早期発見できる

**関連要件**: REQ-CR-006

**詳細シナリオ**:

1. アプリが起動する
2. `main.tsx` で `validateOidcConfig()` が呼び出される
3. 必須環境変数が欠けている場合、明確なエラーメッセージが表示される
4. 全環境変数が設定済みの場合、正常に React アプリがマウントされる

**優先度**: Must Have

---

### ストーリー 2.3: トークン自動リフレッシュ 🟡

**信頼性**: 🟡 *H-08: Claude Frontend が検出、実装パターンは推測*

**私は** Memoru LIFF ユーザー **として**
**長時間使用中にセッションが切れても自動で復旧してほしい**
**そうすることで** ログイン画面に突然戻されずに学習を継続できる

**関連要件**: REQ-CR-007, REQ-CR-102, REQ-CR-103

**詳細シナリオ**:

1. ユーザーが学習中にアクセストークンが期限切れになる
2. API リクエストが 401 を受け取る
3. API クライアントがリフレッシュトークンで新しいアクセストークンを取得
4. 元のリクエストが自動的にリトライされる
5. リフレッシュトークンも期限切れの場合はログイン画面にリダイレクト

**前提条件**:

- リフレッシュトークンが保存されている
- Keycloak がリフレッシュトークンの有効期限内

**優先度**: Should Have

---

### ストーリー 2.4: ProtectedRoute の安全化 🔵

**信頼性**: 🔵 *H-09: Claude Frontend が検出*

**私は** Memoru LIFF ユーザー **として**
**未認証時にログイン画面に正しくリダイレクトされたい**
**そうすることで** ブラウザがフリーズしたり白い画面が表示されたりしない

**関連要件**: REQ-CR-008, REQ-CR-104

**詳細シナリオ**:

1. 未認証ユーザーが ProtectedRoute にアクセス
2. `login()` が 1 回だけ呼び出される
3. `login()` が失敗した場合、エラー画面が表示される（無限ループしない）
4. `login()` が成功した場合、認証後にリダイレクト先のページが表示される

**優先度**: Must Have

---

## エピック3: セキュリティ強化

### ストーリー 3.1: LINE 署名検証のタイミング攻撃対策 🔵

**信頼性**: 🔵 *C-06: Claude Backend が検出、ユーザーが対応確認*

**私は** システム管理者 **として**
**LINE Webhook の署名検証が安全であることを保証したい**
**そうすることで** 不正な Webhook リクエストによるデータ改ざんを防止できる

**関連要件**: REQ-CR-009

**詳細シナリオ**:

1. LINE プラットフォームから Webhook リクエストが送信される
2. 署名ヘッダーが空・null の場合でも `hmac.compare_digest` が使用される
3. 正しい署名の場合のみリクエストが処理される
4. 不正な署名の場合、一定時間で拒否される（タイミング情報が漏洩しない）

**優先度**: Must Have

---

### ストーリー 3.2: CSP 強化 🔵

**信頼性**: 🔵 *H-02: Codex が検出*

**私は** システム管理者 **として**
**XSS 攻撃からユーザーを保護したい**
**そうすることで** 悪意のあるスクリプトの実行を防止できる

**関連要件**: REQ-CR-010

**詳細シナリオ**:

1. CloudFront の ResponseHeadersPolicy から `unsafe-eval` を除去
2. LIFF アプリが CSP 制約下で正常に動作することを確認
3. `unsafe-inline` については LIFF SDK の要件を考慮し、可能な範囲で制限

**前提条件**:

- LIFF SDK が CSP 制約下で動作可能であること

**優先度**: Should Have

---

### ストーリー 3.3: Keycloak HTTPS 強制 🔵

**信頼性**: 🔵 *H-03: Codex が検出*

**私は** システム管理者 **として**
**本番環境の Keycloak が HTTPS でのみアクセスされることを保証したい**
**そうすることで** ユーザーの認証情報が平文で送信されない

**関連要件**: REQ-CR-011, REQ-CR-105

**詳細シナリオ**:

1. 本番環境の Keycloak テンプレートで HTTP を無効化
2. 開発環境では HTTP を許可（ローカルテスト用）
3. 環境パラメータで切り替え可能

**優先度**: Must Have

---

## エピック4: IAM / インフラ修正

### ストーリー 4.1: DuePush Lambda 権限修正 🔵

**信頼性**: 🔵 *C-04: Codex が検出*

**私は** Memoru LIFF ユーザー **として**
**復習通知を1日1回だけ受け取りたい**
**そうすることで** 同じ通知が重複して送られない

**関連要件**: REQ-CR-012

**詳細シナリオ**:

1. EventBridge が DuePush Lambda をトリガー
2. Lambda が復習期限ユーザーに LINE 通知を送信
3. Lambda が Users テーブルの `last_notified_date` を更新（IAM 権限あり）
4. 次回実行時に既に通知済みのユーザーをスキップ

**優先度**: Must Have

---

### ストーリー 4.2: LINE 連携解除 🔵

**信頼性**: 🔵 *H-04: Codex が検出*

**私は** Memoru LIFF ユーザー **として**
**LINE 連携を解除したい**
**そうすることで** LINE 通知の受信を停止できる

**関連要件**: REQ-CR-018

**詳細シナリオ**:

1. ユーザーが LINE 連携画面で「連携解除」ボタンを押す
2. Frontend が Backend の `/users/me/unlink-line` API を呼び出す
3. Backend がユーザーの `line_user_id` を削除
4. LINE 通知が停止される

**優先度**: Should Have

---

### ストーリー 4.3: インフラコスト最適化 🟡

**信頼性**: 🟡 *H-11, H-12: Claude Infra が検出、コスト削減額は推定*

**私は** システム管理者 **として**
**開発環境の運用コストを削減したい**
**そうすることで** 不要な月額費用を抑えられる

**関連要件**: REQ-CR-413, REQ-CR-414

**詳細シナリオ**:

1. 開発環境の NAT Gateway を削除し、ECS タスクを Public Subnet に配置
2. CloudWatch Logs の保存期間を設定（本番 90 日、開発 14 日）
3. 年間 $410-680 のコスト削減を実現

**優先度**: Could Have

---

## エピック5: データ整合性・品質

### ストーリー 5.1: datetime の統一 🔵

**信頼性**: 🔵 *H-01: Codex + Claude Backend が共通検出*

**私は** Memoru LIFF ユーザー **として**
**復習スケジュールが正確に計算されてほしい**
**そうすることで** 適切なタイミングで復習できる

**関連要件**: REQ-CR-013

**詳細シナリオ**:

1. SM-2 アルゴリズムが due 日時を計算
2. 全箇所で `datetime.now(timezone.utc)` が使用される
3. naive datetime と aware datetime の比較で TypeError が発生しない
4. UTC 基準で正確な間隔計算が実行される

**優先度**: Must Have

---

### ストーリー 5.2: カード数制限の Race Condition 対策 🔵

**信頼性**: 🔵 *H-06: Claude Backend が検出*

**私は** Memoru LIFF ユーザー **として**
**カード数上限の 2,000 枚を超えてカードが作成されないでほしい**
**そうすることで** システムの整合性が保たれる

**関連要件**: REQ-CR-015

**詳細シナリオ**:

1. ユーザーのカード数が 2,000 枚に近い状態
2. 同時に複数のカード作成リクエストが到着
3. DynamoDB の ConditionExpression で原子的にカウントをチェック
4. 制限を超えるリクエストは拒否される

**優先度**: Should Have

---

### ストーリー 5.3: Bedrock リトライのジッター追加 🔵

**信頼性**: 🔵 *H-07: Claude Backend が検出*

**私は** 開発者 **として**
**Bedrock API の並列呼び出し時にリクエストが集中しないようにしたい**
**そうすることで** Thundering Herd 問題を回避しサービスの安定性を維持できる

**関連要件**: REQ-CR-016

**詳細シナリオ**:

1. 複数の Lambda が同時に Bedrock API を呼び出す
2. API がスロットリングでエラーを返す
3. 各 Lambda がフルジッター付き Exponential Backoff でリトライ
4. リトライタイミングが分散し、API への負荷が緩和される

**優先度**: Should Have

---

### ストーリー 5.4: Context API のメモ化 🔵

**信頼性**: 🔵 *H-10: Claude Frontend が検出*

**私は** Memoru LIFF ユーザー **として**
**アプリがスムーズに動作してほしい**
**そうすることで** 学習中のもたつきやフリーズがない

**関連要件**: REQ-CR-017

**詳細シナリオ**:

1. CardsContext と AuthContext の Provider 値が `useMemo` でメモ化される
2. コールバック関数が `useCallback` でメモ化される
3. 値が変化していない場合、Consumer コンポーネントが再レンダリングされない
4. アプリのレスポンスが向上

**優先度**: Should Have

---

### ストーリー 5.5: 通知 cron 式の修正 🔵

**信頼性**: 🔵 *H-05: Codex が検出*

**私は** Memoru LIFF ユーザー **として**
**設定した時刻に通知を受け取りたい**
**そうすることで** 自分のペースで学習を計画できる

**関連要件**: REQ-CR-014

**詳細シナリオ**:

1. SAM テンプレートの cron 式が正しい時刻を反映
2. コメントと cron 式の記述が一致
3. ユーザー設定の通知時刻が考慮される

**優先度**: Should Have

---

## ストーリーマップ

```
エピック1: API 契約の整合性確保
├── ストーリー 1.1 (🔵 Must Have) - API ルート統一
├── ストーリー 1.2 (🔵 Must Have) - レスポンス型統一
└── ストーリー 1.3 (🔵 Must Have) - 204 レスポンス処理

エピック2: 認証フローの完成
├── ストーリー 2.1 (🔵 Must Have) - OIDC コールバック
├── ストーリー 2.2 (🔵 Must Have) - 環境変数バリデーション
├── ストーリー 2.3 (🟡 Should Have) - トークンリフレッシュ
└── ストーリー 2.4 (🔵 Must Have) - ProtectedRoute 安全化

エピック3: セキュリティ強化
├── ストーリー 3.1 (🔵 Must Have) - タイミング攻撃対策
├── ストーリー 3.2 (🔵 Should Have) - CSP 強化
└── ストーリー 3.3 (🔵 Must Have) - Keycloak HTTPS

エピック4: IAM / インフラ修正
├── ストーリー 4.1 (🔵 Must Have) - DuePush 権限
├── ストーリー 4.2 (🔵 Should Have) - LINE 連携解除
└── ストーリー 4.3 (🟡 Could Have) - コスト最適化

エピック5: データ整合性・品質
├── ストーリー 5.1 (🔵 Must Have) - datetime 統一
├── ストーリー 5.2 (🔵 Should Have) - Race Condition 対策
├── ストーリー 5.3 (🔵 Should Have) - Bedrock ジッター
├── ストーリー 5.4 (🔵 Should Have) - Context メモ化
└── ストーリー 5.5 (🔵 Should Have) - 通知 cron 修正
```

## 信頼性レベルサマリー

- 🔵 青信号: 16件 (89%)
- 🟡 黄信号: 2件 (11%)
- 🔴 赤信号: 0件 (0%)

**品質評価**: ✅ 高品質（青信号が89%、赤信号なし）
